---
share: true
---
# 内存分配
- 对象(类型对象除外)是分配在堆(heap)上的结构
	- 大内存 > 256k
		- 使用malloc分配内存
		- free函数释放内存
	- 小内存 < 256k
		- 调用malloc函数分配256k的内存，放入内存池中
		- 不释放内存
- 使用引用计数等方法进行垃圾回收
- Ref: https://www.cnblogs.com/geaozhang/p/7111961.html

# 内存回收

## 引用计数
- Approach
	- 每个对象维护一个ob_ref字段
	- 每当新的引用指向该对象时，加1
	- 一旦对象的引用计数为0，该对象即被释放
- Pro → 速度快
- Con
	1. 需维护ob_ref
	2. 引用环
		- 两个对象相互引用
		```
		a = []
		b = [a]
		a.append(b)
		```
		- 容器类对象会有
		- 非容器类不会有，所以直接通过引用计数回收内存

## Mark and Sweep
- 解决循环引用的问题
1. 标记阶段 → 遍历所有的对象，如果还有对象引用它，那么就标记该对象为可达
2. 清除阶段 → 再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收
- 进行Mark and Sweep的时候，整个程序会停下来

## 分代收集
- 为了减小Mark and Sweep的遍历范围
- 维护三个链表: 年轻代，中年代，老年代
- 新创建的对象都会分配在年轻代: 当链表满了, 会触发收集
- 通过标记清除机制获得可被回收的对象
- 不会回收的对象就会被移到中年代 → 依此类推
- 触发
	- 主动调用调用`gc.collect()`
	- 当gc模块的计数器达到阈值的时候
	- 程序退出的时候
- Ref
	- https://zhuanlan.zhihu.com/p/62282961
	- https://zhuanlan.zhihu.com/p/83251959